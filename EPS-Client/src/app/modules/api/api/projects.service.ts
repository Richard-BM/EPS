/**
 * Agency Pulse API v1.0
 * API f√ºr das Agency Pulse - Einsatzplanungssystem
 *
 * OpenAPI spec version: 1.0
 * Contact: development@de.cpm-int.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AreaResponse } from '../model/areaResponse';
import { AttributeCreationRequest } from '../model/attributeCreationRequest';
import { AttributeEditRequest } from '../model/attributeEditRequest';
import { AttributeResponse } from '../model/attributeResponse';
import { CategoryCreationRequest } from '../model/categoryCreationRequest';
import { CategoryEditRequest } from '../model/categoryEditRequest';
import { CategoryResponse } from '../model/categoryResponse';
import { PersonResponse } from '../model/personResponse';
import { ProblemDetails } from '../model/problemDetails';
import { ProjectCreationRequest } from '../model/projectCreationRequest';
import { ProjectEditRequest } from '../model/projectEditRequest';
import { ProjectResponse } from '../model/projectResponse';
import { ReportLinkResponse } from '../model/reportLinkResponse';
import { ReportLinkSaveRequest } from '../model/reportLinkSaveRequest';
import { SettingEditRequest } from '../model/settingEditRequest';
import { SettingResponse } from '../model/settingResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProjectsService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Returns a list of Projects. You can apply filters using the query parameters
     * Returns all Projects in database if no filters are applied.
     * @param expand Returns also related entities if set to &#x27;true&#x27;
     * @param validFrom The date from which the Project can be used
     * @param validTo The date until when the Project can be used
     * @param projectNumber The project number of the project
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsGet(expand?: boolean, validFrom?: Date, validTo?: Date, projectNumber?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ProjectResponse>>;
    public projectsGet(expand?: boolean, validFrom?: Date, validTo?: Date, projectNumber?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ProjectResponse>>>;
    public projectsGet(expand?: boolean, validFrom?: Date, validTo?: Date, projectNumber?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ProjectResponse>>>;
    public projectsGet(expand?: boolean, validFrom?: Date, validTo?: Date, projectNumber?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }
        if (validFrom !== undefined && validFrom !== null) {
            queryParameters = queryParameters.set('validFrom', <any>validFrom.toISOString());
        }
        if (validTo !== undefined && validTo !== null) {
            queryParameters = queryParameters.set('validTo', <any>validTo.toISOString());
        }
        if (projectNumber !== undefined && projectNumber !== null) {
            queryParameters = queryParameters.set('projectNumber', <any>projectNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ProjectResponse>>('get',`${this.basePath}/Projects`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new project based on the given template
     * Creates a new project based on the given template
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsPost(body?: ProjectCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsPost(body?: ProjectCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsPost(body?: ProjectCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsPost(body?: ProjectCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/Projects`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a attribute with the given attributeId
     * Deletes a attribute with the given attribute
     * @param projectId The projectId from the project with contains the attribute
     * @param attributeId The attributeId from the attribute to be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAppointmentAttributesAttributeIdDelete(projectId: string, attributeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdAppointmentAttributesAttributeIdDelete(projectId: string, attributeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdAppointmentAttributesAttributeIdDelete(projectId: string, attributeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdAppointmentAttributesAttributeIdDelete(projectId: string, attributeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAppointmentAttributesAttributeIdDelete.');
        }

        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling projectsProjectIdAppointmentAttributesAttributeIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/appointmentAttributes/${encodeURIComponent(String(attributeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a single attribute within a project
     * Returns a single attribute within a project
     * @param projectId 
     * @param attributeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAppointmentAttributesAttributeIdGet(projectId: string, attributeId: string, observe?: 'body', reportProgress?: boolean): Observable<AttributeResponse>;
    public projectsProjectIdAppointmentAttributesAttributeIdGet(projectId: string, attributeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AttributeResponse>>;
    public projectsProjectIdAppointmentAttributesAttributeIdGet(projectId: string, attributeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AttributeResponse>>;
    public projectsProjectIdAppointmentAttributesAttributeIdGet(projectId: string, attributeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAppointmentAttributesAttributeIdGet.');
        }

        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling projectsProjectIdAppointmentAttributesAttributeIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AttributeResponse>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/appointmentAttributes/${encodeURIComponent(String(attributeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a attribute within a project
     * Updates a category within a project
     * @param projectId The projectId from the project with contains the attribute
     * @param attributeId The attributeId from the attribute to be updated
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAppointmentAttributesAttributeIdPut(projectId: string, attributeId: string, body?: AttributeEditRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdAppointmentAttributesAttributeIdPut(projectId: string, attributeId: string, body?: AttributeEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdAppointmentAttributesAttributeIdPut(projectId: string, attributeId: string, body?: AttributeEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdAppointmentAttributesAttributeIdPut(projectId: string, attributeId: string, body?: AttributeEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAppointmentAttributesAttributeIdPut.');
        }

        if (attributeId === null || attributeId === undefined) {
            throw new Error('Required parameter attributeId was null or undefined when calling projectsProjectIdAppointmentAttributesAttributeIdPut.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/appointmentAttributes/${encodeURIComponent(String(attributeId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of attributes within a project
     * Returns a list of attributes within a project
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAppointmentAttributesGet(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AttributeResponse>>;
    public projectsProjectIdAppointmentAttributesGet(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AttributeResponse>>>;
    public projectsProjectIdAppointmentAttributesGet(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AttributeResponse>>>;
    public projectsProjectIdAppointmentAttributesGet(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAppointmentAttributesGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<AttributeResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/appointmentAttributes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new attribute within a project
     * Creates a new attribute within a project
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAppointmentAttributesPost(projectId: string, body?: AttributeCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdAppointmentAttributesPost(projectId: string, body?: AttributeCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdAppointmentAttributesPost(projectId: string, body?: AttributeCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdAppointmentAttributesPost(projectId: string, body?: AttributeCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAppointmentAttributesPost.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/appointmentAttributes`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a single area
     * Returns a single area
     * @param projectId 
     * @param areaId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAreasAreaIdGet(projectId: string, areaId: string, observe?: 'body', reportProgress?: boolean): Observable<AreaResponse>;
    public projectsProjectIdAreasAreaIdGet(projectId: string, areaId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AreaResponse>>;
    public projectsProjectIdAreasAreaIdGet(projectId: string, areaId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AreaResponse>>;
    public projectsProjectIdAreasAreaIdGet(projectId: string, areaId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAreasAreaIdGet.');
        }

        if (areaId === null || areaId === undefined) {
            throw new Error('Required parameter areaId was null or undefined when calling projectsProjectIdAreasAreaIdGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AreaResponse>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/areas/${encodeURIComponent(String(areaId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of areas for a project
     * Returns a list of areas for a project
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdAreasGet(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AreaResponse>>;
    public projectsProjectIdAreasGet(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AreaResponse>>>;
    public projectsProjectIdAreasGet(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AreaResponse>>>;
    public projectsProjectIdAreasGet(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdAreasGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<AreaResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/areas`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a category with the given categoryId
     * Deletes a category with the given categoryId
     * @param projectId The projectId from the project with contains the category
     * @param categoryId The categoryId from the category to be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdCategoriesCategoryIdDelete(projectId: string, categoryId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdCategoriesCategoryIdDelete(projectId: string, categoryId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdCategoriesCategoryIdDelete(projectId: string, categoryId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdCategoriesCategoryIdDelete(projectId: string, categoryId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdCategoriesCategoryIdDelete.');
        }

        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling projectsProjectIdCategoriesCategoryIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/categories/${encodeURIComponent(String(categoryId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a single category within a project
     * Returns a single category within a project
     * @param projectId 
     * @param categoryId 
     * @param expand Returns also related entities if set to &#x27;true&#x27;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdCategoriesCategoryIdGet(projectId: string, categoryId: string, expand?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<CategoryResponse>>;
    public projectsProjectIdCategoriesCategoryIdGet(projectId: string, categoryId: string, expand?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CategoryResponse>>>;
    public projectsProjectIdCategoriesCategoryIdGet(projectId: string, categoryId: string, expand?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CategoryResponse>>>;
    public projectsProjectIdCategoriesCategoryIdGet(projectId: string, categoryId: string, expand?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdCategoriesCategoryIdGet.');
        }

        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling projectsProjectIdCategoriesCategoryIdGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CategoryResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/categories/${encodeURIComponent(String(categoryId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a category within a project
     * Updates a category within a project
     * @param projectId The projectId from the project with contains the category
     * @param categoryId The categoryId from the category to be updated
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdCategoriesCategoryIdPut(projectId: string, categoryId: string, body?: CategoryEditRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdCategoriesCategoryIdPut(projectId: string, categoryId: string, body?: CategoryEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdCategoriesCategoryIdPut(projectId: string, categoryId: string, body?: CategoryEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdCategoriesCategoryIdPut(projectId: string, categoryId: string, body?: CategoryEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdCategoriesCategoryIdPut.');
        }

        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling projectsProjectIdCategoriesCategoryIdPut.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/categories/${encodeURIComponent(String(categoryId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of categories for a project
     * Returns a list of categories for a project
     * @param projectId 
     * @param expand Returns also related entities if set to &#x27;true&#x27;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdCategoriesGet(projectId: string, expand?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<CategoryResponse>>;
    public projectsProjectIdCategoriesGet(projectId: string, expand?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CategoryResponse>>>;
    public projectsProjectIdCategoriesGet(projectId: string, expand?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CategoryResponse>>>;
    public projectsProjectIdCategoriesGet(projectId: string, expand?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdCategoriesGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<CategoryResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/categories`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new category within a project
     * Creates a new category within a project
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdCategoriesPost(projectId: string, body?: CategoryCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdCategoriesPost(projectId: string, body?: CategoryCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdCategoriesPost(projectId: string, body?: CategoryCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdCategoriesPost(projectId: string, body?: CategoryCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdCategoriesPost.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/categories`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a project with the given projectId
     * Deletes a project with the given projectId
     * @param projectId The projectId from the project to be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdDelete(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdDelete(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdDelete(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdDelete(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a single project
     * Returns a single project
     * @param projectId 
     * @param expand Returns also related entities if set to &#x27;true&#x27;
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdGet(projectId: string, expand?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ProjectResponse>;
    public projectsProjectIdGet(projectId: string, expand?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProjectResponse>>;
    public projectsProjectIdGet(projectId: string, expand?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProjectResponse>>;
    public projectsProjectIdGet(projectId: string, expand?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProjectResponse>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a project with the given projectId
     * Updates a project with the given projectId
     * @param projectId The projectId from the project to be updated
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdPut(projectId: string, body?: ProjectEditRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdPut(projectId: string, body?: ProjectEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdPut(projectId: string, body?: ProjectEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdPut(projectId: string, body?: ProjectEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdPut.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of links to external reportings
     * Returns a list of links to external reportings
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdReportlinksGet(projectId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ReportLinkResponse>>;
    public projectsProjectIdReportlinksGet(projectId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ReportLinkResponse>>>;
    public projectsProjectIdReportlinksGet(projectId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ReportLinkResponse>>>;
    public projectsProjectIdReportlinksGet(projectId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdReportlinksGet.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<ReportLinkResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/reportlinks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new reference to an external report for a project
     * Creates a new reference to an external report for a project
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdReportlinksPost(projectId: string, body?: ReportLinkSaveRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdReportlinksPost(projectId: string, body?: ReportLinkSaveRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdReportlinksPost(projectId: string, body?: ReportLinkSaveRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdReportlinksPost(projectId: string, body?: ReportLinkSaveRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdReportlinksPost.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/reportlinks`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a ReportLink with the given reportLinkId
     * Deletes a ReportLink with the given reportLinkId
     * @param projectId The projectId from the project with contains the ReportLink
     * @param reportLinkId The reportLinkId from the ReportLink to be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdReportlinksReportLinkIdDelete(projectId: string, reportLinkId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdReportlinksReportLinkIdDelete(projectId: string, reportLinkId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdReportlinksReportLinkIdDelete(projectId: string, reportLinkId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdReportlinksReportLinkIdDelete(projectId: string, reportLinkId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdReportlinksReportLinkIdDelete.');
        }

        if (reportLinkId === null || reportLinkId === undefined) {
            throw new Error('Required parameter reportLinkId was null or undefined when calling projectsProjectIdReportlinksReportLinkIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/reportlinks/${encodeURIComponent(String(reportLinkId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param reportLinkId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdReportlinksReportLinkIdPut(projectId: string, reportLinkId: string, body?: ReportLinkSaveRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdReportlinksReportLinkIdPut(projectId: string, reportLinkId: string, body?: ReportLinkSaveRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdReportlinksReportLinkIdPut(projectId: string, reportLinkId: string, body?: ReportLinkSaveRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdReportlinksReportLinkIdPut(projectId: string, reportLinkId: string, body?: ReportLinkSaveRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdReportlinksReportLinkIdPut.');
        }

        if (reportLinkId === null || reportLinkId === undefined) {
            throw new Error('Required parameter reportLinkId was null or undefined when calling projectsProjectIdReportlinksReportLinkIdPut.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/reportlinks/${encodeURIComponent(String(reportLinkId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of settings for a project
     * Returns a list of settings for a project
     * @param projectId 
     * @param categoryCode 1 &#x3D; General;2 &#x3D; Reporting; 3 &#x3D; Freelancer App
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdSettingsGet(projectId: string, categoryCode?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<SettingResponse>>;
    public projectsProjectIdSettingsGet(projectId: string, categoryCode?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SettingResponse>>>;
    public projectsProjectIdSettingsGet(projectId: string, categoryCode?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SettingResponse>>>;
    public projectsProjectIdSettingsGet(projectId: string, categoryCode?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdSettingsGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (categoryCode !== undefined && categoryCode !== null) {
            queryParameters = queryParameters.set('categoryCode', <any>categoryCode);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<SettingResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/settings`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a project-setting with the given projectId
     * Updates a project-setting with the given projectId
     * @param projectId The projectId from the project to be updated
     * @param settingId The settingId from the project-setting to be updated
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdSettingsSettingIdPut(projectId: string, settingId: string, body?: SettingEditRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdSettingsSettingIdPut(projectId: string, settingId: string, body?: SettingEditRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdSettingsSettingIdPut(projectId: string, settingId: string, body?: SettingEditRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdSettingsSettingIdPut(projectId: string, settingId: string, body?: SettingEditRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdSettingsSettingIdPut.');
        }

        if (settingId === null || settingId === undefined) {
            throw new Error('Required parameter settingId was null or undefined when calling projectsProjectIdSettingsSettingIdPut.');
        }


        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/settings/${encodeURIComponent(String(settingId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of users for a project
     * Returns a list of users for a project
     * @param projectId 
     * @param expand 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdUsersGet(projectId: string, expand?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<PersonResponse>>;
    public projectsProjectIdUsersGet(projectId: string, expand?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PersonResponse>>>;
    public projectsProjectIdUsersGet(projectId: string, expand?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PersonResponse>>>;
    public projectsProjectIdUsersGet(projectId: string, expand?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdUsersGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand !== undefined && expand !== null) {
            queryParameters = queryParameters.set('expand', <any>expand);
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<PersonResponse>>('get',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes a person based on der personId from a given project
     * Removes a person based on der personId from a given project
     * @param projectId The projectId from the project with contains the assignend person
     * @param personId The personId from the person to be deleted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public projectsProjectIdUsersPersonIdDelete(projectId: string, personId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public projectsProjectIdUsersPersonIdDelete(projectId: string, personId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public projectsProjectIdUsersPersonIdDelete(projectId: string, personId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public projectsProjectIdUsersPersonIdDelete(projectId: string, personId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling projectsProjectIdUsersPersonIdDelete.');
        }

        if (personId === null || personId === undefined) {
            throw new Error('Required parameter personId was null or undefined when calling projectsProjectIdUsersPersonIdDelete.');
        }

        let headers = this.defaultHeaders;

        // authentication (Bearer) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/Projects/${encodeURIComponent(String(projectId))}/users/${encodeURIComponent(String(personId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
